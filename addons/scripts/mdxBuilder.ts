import destr from "destr";
import fs from "fs-extra";
import path from "pathe";
import { locales } from "../../messages/locales";
import { sitemap } from "../../messages/sitemap";

const messagesDirectory = "messages";
const outputDirectory = "src/content/docs";
const configFilePath = path.join("src/content", "config.ts");

interface JsonContent {
  content?: string;
  title?: string;
}

async function generateFileFromJson(
  filePath: string,
  outputPath: string,
  extension: string,
) {
  console.log(`Reading JSON file: ${filePath}`);
  const fileContent = await fs.readFile(filePath, "utf8");
  const jsonContent: JsonContent = destr(fileContent);

  const fileName = path.basename(filePath, ".json");
  const fileExtension = extension === "mdx" ? ".mdx" : ".md";
  const outputFilePath = outputPath.replace(/\.md$/, fileExtension);

  console.log(
    `Generating ${fileExtension.toUpperCase()} file for: ${fileName}`,
  );

  const mdContent = `<!--
    This is a generated file. Do not edit this file directly.
    To make changes, edit the original sitemap file located at: ${filePath}.
    Last Updated: ${new Date().toLocaleDateString()} (Date Created: ${new Date().toLocaleDateString()})
-->

# ${jsonContent?.title ?? fileName}

${jsonContent?.content ?? ""}
`;

  await fs.mkdir(path.dirname(outputFilePath), { recursive: true });
  await fs.writeFile(outputFilePath, mdContent, "utf8");
  console.log(`Generated ${outputFilePath}`);
}

async function processDirectory(
  inputDirectory: string,
  outputDirectory: string,
) {
  console.log(`Processing directory: ${inputDirectory}`);
  const paths = await fs.readdir(inputDirectory);

  if (paths.length === 0) {
    console.log(`No files or directories found in ${inputDirectory}`);
    return;
  }

  for (const itemPath of paths) {
    const fullPath = path.join(inputDirectory, itemPath);
    const stats = await fs.stat(fullPath);
    console.log(
      `Checking path: ${fullPath}, isDirectory: ${stats.isDirectory()}`,
    );

    if (stats.isDirectory()) {
      await processDirectory(fullPath, outputDirectory);
    } else if (path.extname(fullPath) === ".json") {
      const localeName = path.basename(fullPath, ".json");
      const relativePath = path.relative(messagesDirectory, fullPath);

      const cleanedRelativePath = relativePath
        .replace(/^docs[\\/]/, "")
        .replace(/^locales[\\/]/, "")
        .replace(new RegExp(`\\${path.sep}${localeName}.json$`), "");

      const pathParts = cleanedRelativePath.split(path.sep);
      let currentSitemapEntry: any = sitemap;
      for (const part of pathParts) {
        if (currentSitemapEntry && typeof currentSitemapEntry === "object") {
          currentSitemapEntry = currentSitemapEntry[part];
        } else {
          currentSitemapEntry = null;
          break;
        }
      }

      const extension = currentSitemapEntry?.ext || "md";
      let outputFilePath: string;

      if (localeName === "en") {
        outputFilePath = path.join(
          outputDirectory,

          `${cleanedRelativePath}.${extension}`,
        );
      } else {
        outputFilePath = path.join(
          outputDirectory,
          localeName,

          `${cleanedRelativePath}.${extension}`,
        );
      }

      console.log(`Generating file at path: ${outputFilePath}`);

      await generateFileFromJson(fullPath, outputFilePath, extension);
    }
  }
}

async function generateStructureFromConfig() {
  console.log(
    "Updating content folder structure based on locales and sitemap from sitemap.ts...",
  );

  console.log(
    `Generating folder structure for locales: ${Object.keys(locales).join(", ")}`,
  );
  for (const localeKey of Object.keys(locales)) {
    await createFolderStructure(sitemap, localeKey);
  }
}

async function createFolderStructure(
  sitemap: Record<string, any>,
  localeKey: string,
  currentPath = "",
) {
  for (const key of Object.keys(sitemap)) {
    const value = sitemap[key];

    // biome-ignore lint/suspicious/noImplicitAnyLet: <explanation>
    let fullPath;

    // eslint-disable-next-line prefer-const
    fullPath = path.join(messagesDirectory, currentPath, key);

    if (typeof value.ext === "string") {
      const folderPath = fullPath;

      console.log(`Ensuring directory exists: ${folderPath}`);
      await fs.mkdir(folderPath, { recursive: true });

      const jsonFilePath = path.join(folderPath, `${localeKey}.json`);

      if (!(await fs.pathExists(jsonFilePath))) {
        console.log(`Creating missing JSON file: ${jsonFilePath}`);
        await fs.writeFile(
          jsonFilePath,
          JSON.stringify({ title: "", content: "" }, null, 2),
          "utf8",
        );
      }
    } else {
      await createFolderStructure(
        value,
        localeKey,
        path.join(currentPath, key),
      );
    }
  }
}

async function createConfigFile() {
  if (!(await fs.pathExists(configFilePath))) {
    console.log(`Creating missing config.ts file at: ${configFilePath}`);
    const configContent = `
import { docsSchema } from "@astrojs/starlight/schema";
import { defineCollection } from "astro:content";

export const collections = {
  docs: defineCollection({ schema: docsSchema() }),
};
`;
    await fs.writeFile(configFilePath, configContent.trim(), "utf8");
    console.log(`config.ts file created at ${configFilePath}`);
  } else {
    console.log("config.ts already exists, skipping creation.");
  }
}

async function main() {
  console.log("Checking if output directory exists...");

  const contentDir = path.join(outputDirectory, "..");
  if (!(await fs.pathExists(contentDir))) {
    console.log(`Creating directory: ${contentDir}`);
    await fs.mkdir(contentDir, { recursive: true });
  }

  await createConfigFile();

  console.log("Generating structure based on sitemap from sitemap.ts...");
  await generateStructureFromConfig();

  console.log("Starting to process messages directory...");
  await processDirectory(messagesDirectory, outputDirectory);
  console.log("Processing completed.");
}

main().catch((error: unknown) => {
  console.error("An error occurred:", error);
});
